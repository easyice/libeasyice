/*
MIT License

Copyright  (c) 2009-2019 easyice

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/* Generated by Together */

#include "CAnalyzeTable.h"
#include "../arithmetic.h"


tables::CAnalyzeTable::CAnalyzeTable()
{
	Init();
}

tables::CAnalyzeTable::~CAnalyzeTable()
{

}

void tables::CAnalyzeTable::PushBackTsPacket(CTsPacket* tsPacket)
{
	int pid = tsPacket->Get_PID();


	//二分查找，看是否在PID列表中出现
	if (BinarySearch(&(m_vecPidFilterList[0]),pid,(int)m_vecPidFilterList.size()) != -1)	//找到
	{
		m_buildSection.AddPacket(tsPacket->m_pPacket,m_nTsLength);
	}
}

void tables::CAnalyzeTable::InitPidFilterList()
{
	m_vecPidFilterList.clear();

	m_vecPidFilterList.push_back(0x0);		//PAT
	m_vecPidFilterList.push_back(0x1);		//CAT
	m_vecPidFilterList.push_back(0x2);		//TSDT

	for (int i = 0x3; i <= 0xF; i++)
	{
		m_vecPidFilterList.push_back(i);	//预留
	}

	m_vecPidFilterList.push_back(0x10);		//NIT,ST
	m_vecPidFilterList.push_back(0x11);		//SDT,BAT,ST
	m_vecPidFilterList.push_back(0x12);		//EIT,ST
	m_vecPidFilterList.push_back(0x13);		//RST,ST
	m_vecPidFilterList.push_back(0x14);		//TDT,TOT,ST
	m_vecPidFilterList.push_back(0x15);		//网络同步

	for (int i = 0x16; i <= 0x1B; i++)
	{
		m_vecPidFilterList.push_back(i);	//预留
	}

	m_vecPidFilterList.push_back(0x1C);		//带刃帕
	m_vecPidFilterList.push_back(0x1D);		//测量
	m_vecPidFilterList.push_back(0x1E);		//DIT
	m_vecPidFilterList.push_back(0x1F);		//SIT
}

int tables::CAnalyzeTable::ParseFindPAT(BYTE* pData, int nLength)
{
	//首先解析PAT，保存PMT PID列表
	int rtn = -1;
	CTsPacket tsPacket;
	SECTION_BUFFER buf;
	TABLES tables;
	CBuildUpSection builder;

	builder.SetSectionBuffer(&buf);
	builder.SetTablesBuffer(&tables);

	for (int i = 0; i < nLength; i += m_nTsLength)
	{
		if (!tsPacket.SetPacket(pData + i))
		{
			continue;
		}
		if (tsPacket.Get_PID() == 0x0)
		{
			builder.AddPacket(pData + i,m_nTsLength);
			if (tables.vecTabPAT.size() > 0)	//已经组完并解析完
			{
				//....
				STU_SECTION_PAT& pat =  tables.vecTabPAT[0];	//认为只有一个PAT表
				STU_SECTION_PAT::iterator it;
				for (it = pat.begin(); it != pat.end(); it++)	//分析每个解析完的section表
				{
					ParsePATForPMTPID(*it);
				}
				rtn = 0;
				break;
			}
		}
	}

	//已更新pid列表。对其从小到大排序
	std::sort(m_vecPidFilterList.begin(),m_vecPidFilterList.end());
	return rtn;
}

void tables::CAnalyzeTable::Init()
{
	m_bPatParsed = false;
	m_nTsLength = 188;

	m_mapSectionData.clear();
	m_tables.clear();
	m_vecPidFilterList.clear();
	InitPidFilterList();
	m_buildSection.SetSectionBuffer(&m_mapSectionData);
	m_buildSection.SetTablesBuffer(&m_tables);
}

void tables::CAnalyzeTable::SetTsPacketLength(int nLength)
{
	m_nTsLength = nLength;
}

void tables::CAnalyzeTable::ParsePATForPMTPID(const PAT& pat)
{
	const vector<PAT_LIST>& vec_pat_list = pat.vec_pat_list;
	vector<PAT_LIST>::const_iterator it;

	for (it = vec_pat_list.begin(); it != vec_pat_list.end(); it++)
	{
		m_vecPidFilterList.push_back(it->network_pmt_PID);
		if (it->program_number != 0)
		{
			m_vecPmtPidList.push_back(it->network_pmt_PID);
		}
	}
}

tables::TABLES* tables::CAnalyzeTable::GetTables()
{
	return &m_tables;
}

void tables::CAnalyzeTable::SetNetworkPmtPidList(const vector<int>& vecPidList)
{
	vector<int>::const_iterator it = vecPidList.begin();
	for (; it != vecPidList.end();++it)
	{
		m_vecPidFilterList.push_back(*it);
	}

	//已更新pid列表。对其从小到大排序
	std::sort(m_vecPidFilterList.begin(),m_vecPidFilterList.end());
}

void tables::CAnalyzeTable::PushBackTsPacket2(BYTE* pPacket)
{
	CTsPacket tsPacket;
	if (!tsPacket.SetPacket(pPacket))
	{
		return;
	}

	if (m_bPatParsed)
	{
		PushBackTsPacket(&tsPacket);
		return;
	}

	//寻找PAT并解析.
	if (tsPacket.Get_PID() != 0x0)
	{
		return;
	}

	m_buildSectionPat.SetSectionBuffer(&m_mapSectionData);
	m_buildSectionPat.SetTablesBuffer(&m_tables);

	m_buildSectionPat.AddPacket(pPacket,m_nTsLength);

	if (m_tables.vecTabPAT.empty())
	{
		return;
	}

	//已经组完并解析完
	STU_SECTION_PAT& pat =  m_tables.vecTabPAT[0];	//认为只有一个PAT表
	STU_SECTION_PAT::iterator it;
	for (it = pat.begin(); it != pat.end(); it++)	//分析每个解析完的section表
	{
		ParsePATForPMTPID(*it);
	}

	//已更新pid列表。对其从小到大排序
	std::sort(m_vecPidFilterList.begin(),m_vecPidFilterList.end());
	m_bPatParsed = true;

}
